{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction # This is the documentation of 88mph , a fixed-rate yield-generation protocol. You can find the source code of 88mph on GitHub . To learn about how 88mph achieves fixed-rate interest, check out How 88mph works .","title":"Introduction"},{"location":"#introduction","text":"This is the documentation of 88mph , a fixed-rate yield-generation protocol. You can find the source code of 88mph on GitHub . To learn about how 88mph achieves fixed-rate interest, check out How 88mph works .","title":"Introduction"},{"location":"addresses/","text":"Smart contract addresses # MPH token & staking # MPHToken deployed at 0x8888801aF4d980682e47f1A9036e589479e835C5 MPH-ETH LP token: 0x4d96369002fc5b9687ee924d458a7e5baa5df34e ClonedRewardsFactory: 0x4b52448393b8EcF8D56186887976c794056C6C68 LP rewards pool: 0xd48Df82a6371A9e0083FbfC0DF3AF641b8E21E44 Shared # Governance treasury: 0x56f34826Cc63151f74FA8f701E4f73C5EAae52AD Governance timelock: 0x4027d912A19E3Cd540FB580aF6A9088eAC738566 Developer wallet: 0xfecBad5D60725EB6fd10f8936e02fa203fd27E4b Rewards deployed at 0x98df8D9E56b51e4Ea8AA9b57F8A5Df7A044234e1 Dumper deployed at 0x5B3C81C86d17786255904c316bFCB38A46146ef8 PercentageFeeModel deployed at 0x11b2F96C0040C0189FD9F6C4405d086B03Bc41AB LinearInterestModel deployed at 0xE82698d8D51b36Cabd5897F2AD30d4cF654d7411 MPHIssuanceModel01 deployed at 0x36aD542daDc22078511D64b98aFF818aBD1AC713 Vesting deployed at 0x8943eb8F104bCf826910e7d2f4D59edfe018e0e7 MPHMinter deployed at 0x03577A2151A10675a9689190fE5D331Ee7ff2517 NFTFactory deployed at 0x95816Fa25D54061086d4f4aD9a48FDBe9068E541 FractionalDepositTemplate deployed at 0x2263655696Fc5c5a4aE2BaCaED29b88708bcc958 FractionalDepositFactory deployed at 0xED2FF23AEE9108cc9576179E0C4c12A879c3Eb46 ZeroCouponBondTemplate deployed at 0x36852895B00EbD95e1B0C4d92646FFF108FEcc03 ZeroCouponBondFactory deployed at 0xE74b4CaA808c52F3b1101AF54C59f2598cD2D279 Zero coupon bonds # Compound UNI # 88MPH-COMP-UNI-AUG-2021: 0x557b8931bfb3650493fb4f434138f445af9229e8 88MPH-COMP-UNI-FEB-2022: 0x85034b3b2e292493d029443455cc62ab669573b3 Harvest 3CRV # 88MPH-HARVEST-3CRV-AUG-2021: 0x23c6ab8b52975551448fbddf2e494ae57645c200 88MPH-HARVEST-3CRV-FEB-2022: 0x6d6d543fe4e2f62dd0c9d4a79e18f0b43ddd12ea Pools # cDAI # CompoundERC20Market deployed at 0xB45badB785142e6f459a8f5F724B6688cef311FD EMAOracle deployed at 0x4d986F2607A1f54De55ec7fff332A13d076ef160 88mph cDAI Pool Deposit deployed at 0x9D481E42d9A2b52397262Cdbe76ABf3ca7b52203 88mph cDAI Pool Bond deployed at 0x4A201E1B6d1ffAdEBE7C873f32a14473169B723B 88mph cDAI Pool deployed at 0x35966201A7724b952455B73A36C8846D8745218e cUSDC # CompoundERC20Market deployed at 0xaDEDB64E36ba329FD116269A62276B1Ba5d039Dc EMAOracle deployed at 0xBeC287DEED87b01EB64C8bD2E10558700E3AE156 88mph cUSDC Pool Deposit deployed at 0xE0CFDcCc6CD391DC8de1F7a2B2b5424131a87382 88mph cUSDC Pool Bond deployed at 0x5396CFB525C0d166621FA1e22A2A343BC5441c74 88mph cUSDC Pool deployed at 0x374226dbAa3e44bF3923AfB63f5Fd83928B7e148 cUNI # CompoundERC20Market deployed at 0xb5d7BE07Cc7F03c8340A3F492357137438778aFF EMAOracle deployed at 0xc5161483Fa46ff3C909C9d80135C24Fa5986d66F 88mph cUNI Pool Deposit deployed at 0x8AF47056903E5FF85dcf5E024427c3e4A3E5E69E 88mph cUNI Pool Bond deployed at 0x20e9245821B4c56ae6693bc42d5845b063189a00 88mph cUNI Pool deployed at 0x19E10132841616CE4790920d5f94B8571F9b9341 yUSD # YVaultMarket deployed at 0x37315Cdf1d097dfAb8267c0c1Aef6fECaC09d845 EMAOracle deployed at 0x7acD00D3e1Cf5018D8530f55f9F19910c3358159 88mph yCRV Pool Deposit deployed at 0x7A2e4b5627a07120770b1D64A9ea021E801165c3 88mph yCRV Pool Bond deployed at 0xD32D197277c3364Ea70da7bAd454278cfdbaAF4c 88mph yCRV Pool deployed at 0xe615e59353f70cA2424Aa0F24F49C639B8E924D3 ycrvSBTC # YVaultMarket deployed at 0x10f1a7F480c75E6e434d35b025dF4e6C1FC26Db7 EMAOracle deployed at 0x58CcE424c3098772387C7c7a35011A82569D78c6 88mph crvSBTC Pool Deposit deployed at 0xcc2f73fC7C8ebDfB3f9de9F7Ac16E53F9Aaf3aBD 88mph crvSBTC Pool Bond deployed at 0x073A4324A168D8Dc76596FB50920593092866A3c 88mph crvSBTC Pool deployed at 0x681Aaa7CF3F7E1f110842f0149bA8A4AF53Ef2Fd Harvest yCRV # HarvestMarket deployed at 0xD4AA5cC7Eb7f471F44bb744F518C5F3d937cc403 PercentageFeeModel deployed at 0xD817Ec04440c51Ec9B34B9625357e308b6A06348 EMAOracle deployed at 0x322C4F9A477f99b3AEc04dE27c8d97FddaD34309 88mph Harvest yCRV Pool Deposit deployed at 0xF1Ae2f6991B7255d3B5266e6c56333858b3ebDD6 88mph Harvest yCRV Pool Bond deployed at 0x57597c75D9f6faecb1Aa08eE6a324c48E55704E4 88mph Harvest yCRV Pool deployed at 0x23Fa6b36E870ca5753853538D17C3ca7f5269e84 Aave v2 USDC # AaveMarket deployed at 0xB558fD7F1927CeB334bf661acc5C6a11C103fc91 EMAOracle deployed at 0xdde39fDd51a4783685622984b4c5E757Db6beCb0 88mph aUSDC Pool Deposit deployed at 0xdaA6BD333c83362579D9621954e9451E319D09ea 88mph aUSDC Pool Bond deployed at 0x9C4beC382195a4CCE7CfcD18813b3F8Da1aA162B 88mph aUSDC Pool deployed at 0xe8C52367b81113ED32bb276184e521C2fbE9393A Harvest crvHUSD # HarvestMarket deployed at 0x095cCFeDF134D20a033eeA5ab124C03777e8B0B0 EMAOracle deployed at 0x64eC20abf1760a9D8a2DF69a1a10D2Ee76D7675c 88mph Harvest crvHUSD Pool Deposit deployed at 0xEE49eCECa7853104A2Ac68FafF8568598F8AF226 88mph Harvest crvHUSD Pool Bond deployed at 0x6E3e1AB141F20FD89856677F1Ea2366C6A6aB326 88mph Harvest crvHUSD Pool deployed at 0xb1ABAac351e06d40441CF2CD97F6f0098e6473F2 Harvest 3CRV # HarvestMarket deployed at 0x68c16B704567F23a59615Fd7dc38ebE9E6768a1F EMAOracle deployed at 0xCf208972255B9f21B71f7ca2B0b4Df93Ca006150 88mph Harvest 3CRV Pool Deposit deployed at 0xeC5B08D6113A98EDb872fA2D8edfA9F2472b823c 88mph Harvest 3CRV Pool Bond deployed at 0x5421eA9A76f116B283385a82fC50b64Cf2121A64 88mph Harvest 3CRV Pool deployed at 0x2F3EFD1a90a2336ab8fa1B9060380DC37361Ca55 Harvest crvHBTC # HarvestMarket deployed at 0xF34c3AEA5261864B40b8a5aFd3bE8d9AABdD96f9 EMAOracle deployed at 0x8fB81eB0ee694089Bfe9b58200287cA30422E2B3 88mph Harvest crvHBTC Pool Deposit deployed at 0x75e2ADA00724e30bF9A19F2565aBF40608B12697 88mph Harvest crvHBTC Pool Bond deployed at 0x18d1AE63b388a6581CdF8a9b7336F74bF2e75532 88mph Harvest crvHBTC Pool deployed at 0x3f5611F7762cc39FC11E10C864ae38526f650e9D Aave v2 sUSD # AaveMarket deployed at 0x473cA701B5279C3F0d54C059d8c29B8ad470B44D EMAOracle deployed at 0xF38cA0CFFc53A6B6C62c2bE87967fcc13e807751 88mph aSUSD Pool Deposit deployed at 0x38E5bE1EcE9407F7619d6147fE64B29f6a732650 88mph aSUSD Pool Bond deployed at 0x2C0869bAC0a95a5ca7D48e14570A57171aefC252 88mph aSUSD Pool deployed at 0x6712BAab01FA2dc7bE6635746Ec2Da6F8Bd73e71 Aave v2 DAI # AaveMarket deployed at 0x90757D5e68A725Fc5f7b13ecdD72cDdd5B8Fa979 EMAOracle deployed at 0x8f70B80ecb1786b21931dD73A8B895d263D52BB5 88mph aDAI Pool Deposit deployed at 0x119b0CED87474543634226ef37058Eb3d2B18355 88mph aDAI Pool Bond deployed at 0x17ae119d1702210F86ec4a228Ff728e7606D7de7 88mph aDAI Pool deployed at 0xDC86AC6140026267E0873B27c8629eFE748E7146 Harvest crvOBTC # HarvestMarket deployed at 0xa3b7A9368408dA40136cD219A91f7f571eE68a36 EMAOracle deployed at 0x984570fB7eA89a7991E827aA1844753Ed0C27460 88mph Harvest crvOBTC Pool Deposit deployed at 0xa8c9A5F33b0E0bD0c46025282E8B2E9C49781a18 88mph Harvest crvOBTC Pool Bond deployed at 0xD158c1d945F504b53951CA71E743F5965a6E5d26 88mph Harvest crvOBTC Pool deployed at 0xD4837145c7e13D580904e8431cfD481f9794fC41 yEarn aLINK # YVaultMarket deployed at 0x08cC88c379911BF6d778081a078B48bd7035fB70 EMAOracle deployed at 0xb0f8FAF712fEa939CAE787DB171661C08DCfA7d8 88mph yaLINK Pool Deposit deployed at 0xF0b7DE03134857391d8D43Ed48e20EDF21461097 88mph yaLINK Pool Bond deployed at 0x140716901E0e17E0EE80daf560A21F85E09A3A16 88mph yaLINK Pool deployed at 0x904F81EFF3c35877865810CCA9a63f2D9cB7D4DD Harvest CRV:STETH # HarvestMarket deployed at 0xC03e7F63A6Be1198127B7a6eEb5ecD0FBCfF6381 EMAOracle deployed at 0x63667C9390Dcb2D9b3f9b8Ac3321d916B4710532 88mph Harvest CRV:STETH Pool Deposit deployed at 0x6a76f1c362f2C871BEB9d930c9eFd02B07841A28 88mph Harvest CRV:STETH Pool Bond deployed at 0x485Efaa71A64C9283f7cf7Ef444751eB31281795 88mph Harvest CRV:STETH Pool deployed at 0x303CB7Ede0c3AD99CE017CDC3aBAcD65164Ff486 Harvest CRV:RENWBTC # HarvestMarket deployed at 0xD614307FbE4ecE3960f2BB6Ec7863905515AF037 EMAOracle deployed at 0x0AA404FdDFf7943d8b87089F009a7b98EAFC8f8B 88mph Harvest CRV:RENWBTC Pool Deposit deployed at 0xa08b1215ff7Ad33fa431E35569F95F684Cd9Bf9c 88mph Harvest CRV:RENWBTC Pool Bond deployed at 0x3c835F69208884A553025a3B3d2AE46D3b059852 88mph Harvest CRV:RENWBTC Pool deployed at 0x22E6b9A65163CE1225D1F65EF7942a979d093039","title":"Smart contract addresses"},{"location":"addresses/#smart-contract-addresses","text":"","title":"Smart contract addresses"},{"location":"addresses/#mph-token-staking","text":"MPHToken deployed at 0x8888801aF4d980682e47f1A9036e589479e835C5 MPH-ETH LP token: 0x4d96369002fc5b9687ee924d458a7e5baa5df34e ClonedRewardsFactory: 0x4b52448393b8EcF8D56186887976c794056C6C68 LP rewards pool: 0xd48Df82a6371A9e0083FbfC0DF3AF641b8E21E44","title":"MPH token &amp; staking"},{"location":"addresses/#shared","text":"Governance treasury: 0x56f34826Cc63151f74FA8f701E4f73C5EAae52AD Governance timelock: 0x4027d912A19E3Cd540FB580aF6A9088eAC738566 Developer wallet: 0xfecBad5D60725EB6fd10f8936e02fa203fd27E4b Rewards deployed at 0x98df8D9E56b51e4Ea8AA9b57F8A5Df7A044234e1 Dumper deployed at 0x5B3C81C86d17786255904c316bFCB38A46146ef8 PercentageFeeModel deployed at 0x11b2F96C0040C0189FD9F6C4405d086B03Bc41AB LinearInterestModel deployed at 0xE82698d8D51b36Cabd5897F2AD30d4cF654d7411 MPHIssuanceModel01 deployed at 0x36aD542daDc22078511D64b98aFF818aBD1AC713 Vesting deployed at 0x8943eb8F104bCf826910e7d2f4D59edfe018e0e7 MPHMinter deployed at 0x03577A2151A10675a9689190fE5D331Ee7ff2517 NFTFactory deployed at 0x95816Fa25D54061086d4f4aD9a48FDBe9068E541 FractionalDepositTemplate deployed at 0x2263655696Fc5c5a4aE2BaCaED29b88708bcc958 FractionalDepositFactory deployed at 0xED2FF23AEE9108cc9576179E0C4c12A879c3Eb46 ZeroCouponBondTemplate deployed at 0x36852895B00EbD95e1B0C4d92646FFF108FEcc03 ZeroCouponBondFactory deployed at 0xE74b4CaA808c52F3b1101AF54C59f2598cD2D279","title":"Shared"},{"location":"addresses/#zero-coupon-bonds","text":"","title":"Zero coupon bonds"},{"location":"addresses/#compound-uni","text":"88MPH-COMP-UNI-AUG-2021: 0x557b8931bfb3650493fb4f434138f445af9229e8 88MPH-COMP-UNI-FEB-2022: 0x85034b3b2e292493d029443455cc62ab669573b3","title":"Compound UNI"},{"location":"addresses/#harvest-3crv","text":"88MPH-HARVEST-3CRV-AUG-2021: 0x23c6ab8b52975551448fbddf2e494ae57645c200 88MPH-HARVEST-3CRV-FEB-2022: 0x6d6d543fe4e2f62dd0c9d4a79e18f0b43ddd12ea","title":"Harvest 3CRV"},{"location":"addresses/#pools","text":"","title":"Pools"},{"location":"addresses/#cdai","text":"CompoundERC20Market deployed at 0xB45badB785142e6f459a8f5F724B6688cef311FD EMAOracle deployed at 0x4d986F2607A1f54De55ec7fff332A13d076ef160 88mph cDAI Pool Deposit deployed at 0x9D481E42d9A2b52397262Cdbe76ABf3ca7b52203 88mph cDAI Pool Bond deployed at 0x4A201E1B6d1ffAdEBE7C873f32a14473169B723B 88mph cDAI Pool deployed at 0x35966201A7724b952455B73A36C8846D8745218e","title":"cDAI"},{"location":"addresses/#cusdc","text":"CompoundERC20Market deployed at 0xaDEDB64E36ba329FD116269A62276B1Ba5d039Dc EMAOracle deployed at 0xBeC287DEED87b01EB64C8bD2E10558700E3AE156 88mph cUSDC Pool Deposit deployed at 0xE0CFDcCc6CD391DC8de1F7a2B2b5424131a87382 88mph cUSDC Pool Bond deployed at 0x5396CFB525C0d166621FA1e22A2A343BC5441c74 88mph cUSDC Pool deployed at 0x374226dbAa3e44bF3923AfB63f5Fd83928B7e148","title":"cUSDC"},{"location":"addresses/#cuni","text":"CompoundERC20Market deployed at 0xb5d7BE07Cc7F03c8340A3F492357137438778aFF EMAOracle deployed at 0xc5161483Fa46ff3C909C9d80135C24Fa5986d66F 88mph cUNI Pool Deposit deployed at 0x8AF47056903E5FF85dcf5E024427c3e4A3E5E69E 88mph cUNI Pool Bond deployed at 0x20e9245821B4c56ae6693bc42d5845b063189a00 88mph cUNI Pool deployed at 0x19E10132841616CE4790920d5f94B8571F9b9341","title":"cUNI"},{"location":"addresses/#yusd","text":"YVaultMarket deployed at 0x37315Cdf1d097dfAb8267c0c1Aef6fECaC09d845 EMAOracle deployed at 0x7acD00D3e1Cf5018D8530f55f9F19910c3358159 88mph yCRV Pool Deposit deployed at 0x7A2e4b5627a07120770b1D64A9ea021E801165c3 88mph yCRV Pool Bond deployed at 0xD32D197277c3364Ea70da7bAd454278cfdbaAF4c 88mph yCRV Pool deployed at 0xe615e59353f70cA2424Aa0F24F49C639B8E924D3","title":"yUSD"},{"location":"addresses/#ycrvsbtc","text":"YVaultMarket deployed at 0x10f1a7F480c75E6e434d35b025dF4e6C1FC26Db7 EMAOracle deployed at 0x58CcE424c3098772387C7c7a35011A82569D78c6 88mph crvSBTC Pool Deposit deployed at 0xcc2f73fC7C8ebDfB3f9de9F7Ac16E53F9Aaf3aBD 88mph crvSBTC Pool Bond deployed at 0x073A4324A168D8Dc76596FB50920593092866A3c 88mph crvSBTC Pool deployed at 0x681Aaa7CF3F7E1f110842f0149bA8A4AF53Ef2Fd","title":"ycrvSBTC"},{"location":"addresses/#harvest-ycrv","text":"HarvestMarket deployed at 0xD4AA5cC7Eb7f471F44bb744F518C5F3d937cc403 PercentageFeeModel deployed at 0xD817Ec04440c51Ec9B34B9625357e308b6A06348 EMAOracle deployed at 0x322C4F9A477f99b3AEc04dE27c8d97FddaD34309 88mph Harvest yCRV Pool Deposit deployed at 0xF1Ae2f6991B7255d3B5266e6c56333858b3ebDD6 88mph Harvest yCRV Pool Bond deployed at 0x57597c75D9f6faecb1Aa08eE6a324c48E55704E4 88mph Harvest yCRV Pool deployed at 0x23Fa6b36E870ca5753853538D17C3ca7f5269e84","title":"Harvest yCRV"},{"location":"addresses/#aave-v2-usdc","text":"AaveMarket deployed at 0xB558fD7F1927CeB334bf661acc5C6a11C103fc91 EMAOracle deployed at 0xdde39fDd51a4783685622984b4c5E757Db6beCb0 88mph aUSDC Pool Deposit deployed at 0xdaA6BD333c83362579D9621954e9451E319D09ea 88mph aUSDC Pool Bond deployed at 0x9C4beC382195a4CCE7CfcD18813b3F8Da1aA162B 88mph aUSDC Pool deployed at 0xe8C52367b81113ED32bb276184e521C2fbE9393A","title":"Aave v2 USDC"},{"location":"addresses/#harvest-crvhusd","text":"HarvestMarket deployed at 0x095cCFeDF134D20a033eeA5ab124C03777e8B0B0 EMAOracle deployed at 0x64eC20abf1760a9D8a2DF69a1a10D2Ee76D7675c 88mph Harvest crvHUSD Pool Deposit deployed at 0xEE49eCECa7853104A2Ac68FafF8568598F8AF226 88mph Harvest crvHUSD Pool Bond deployed at 0x6E3e1AB141F20FD89856677F1Ea2366C6A6aB326 88mph Harvest crvHUSD Pool deployed at 0xb1ABAac351e06d40441CF2CD97F6f0098e6473F2","title":"Harvest crvHUSD"},{"location":"addresses/#harvest-3crv_1","text":"HarvestMarket deployed at 0x68c16B704567F23a59615Fd7dc38ebE9E6768a1F EMAOracle deployed at 0xCf208972255B9f21B71f7ca2B0b4Df93Ca006150 88mph Harvest 3CRV Pool Deposit deployed at 0xeC5B08D6113A98EDb872fA2D8edfA9F2472b823c 88mph Harvest 3CRV Pool Bond deployed at 0x5421eA9A76f116B283385a82fC50b64Cf2121A64 88mph Harvest 3CRV Pool deployed at 0x2F3EFD1a90a2336ab8fa1B9060380DC37361Ca55","title":"Harvest 3CRV"},{"location":"addresses/#harvest-crvhbtc","text":"HarvestMarket deployed at 0xF34c3AEA5261864B40b8a5aFd3bE8d9AABdD96f9 EMAOracle deployed at 0x8fB81eB0ee694089Bfe9b58200287cA30422E2B3 88mph Harvest crvHBTC Pool Deposit deployed at 0x75e2ADA00724e30bF9A19F2565aBF40608B12697 88mph Harvest crvHBTC Pool Bond deployed at 0x18d1AE63b388a6581CdF8a9b7336F74bF2e75532 88mph Harvest crvHBTC Pool deployed at 0x3f5611F7762cc39FC11E10C864ae38526f650e9D","title":"Harvest crvHBTC"},{"location":"addresses/#aave-v2-susd","text":"AaveMarket deployed at 0x473cA701B5279C3F0d54C059d8c29B8ad470B44D EMAOracle deployed at 0xF38cA0CFFc53A6B6C62c2bE87967fcc13e807751 88mph aSUSD Pool Deposit deployed at 0x38E5bE1EcE9407F7619d6147fE64B29f6a732650 88mph aSUSD Pool Bond deployed at 0x2C0869bAC0a95a5ca7D48e14570A57171aefC252 88mph aSUSD Pool deployed at 0x6712BAab01FA2dc7bE6635746Ec2Da6F8Bd73e71","title":"Aave v2 sUSD"},{"location":"addresses/#aave-v2-dai","text":"AaveMarket deployed at 0x90757D5e68A725Fc5f7b13ecdD72cDdd5B8Fa979 EMAOracle deployed at 0x8f70B80ecb1786b21931dD73A8B895d263D52BB5 88mph aDAI Pool Deposit deployed at 0x119b0CED87474543634226ef37058Eb3d2B18355 88mph aDAI Pool Bond deployed at 0x17ae119d1702210F86ec4a228Ff728e7606D7de7 88mph aDAI Pool deployed at 0xDC86AC6140026267E0873B27c8629eFE748E7146","title":"Aave v2 DAI"},{"location":"addresses/#harvest-crvobtc","text":"HarvestMarket deployed at 0xa3b7A9368408dA40136cD219A91f7f571eE68a36 EMAOracle deployed at 0x984570fB7eA89a7991E827aA1844753Ed0C27460 88mph Harvest crvOBTC Pool Deposit deployed at 0xa8c9A5F33b0E0bD0c46025282E8B2E9C49781a18 88mph Harvest crvOBTC Pool Bond deployed at 0xD158c1d945F504b53951CA71E743F5965a6E5d26 88mph Harvest crvOBTC Pool deployed at 0xD4837145c7e13D580904e8431cfD481f9794fC41","title":"Harvest crvOBTC"},{"location":"addresses/#yearn-alink","text":"YVaultMarket deployed at 0x08cC88c379911BF6d778081a078B48bd7035fB70 EMAOracle deployed at 0xb0f8FAF712fEa939CAE787DB171661C08DCfA7d8 88mph yaLINK Pool Deposit deployed at 0xF0b7DE03134857391d8D43Ed48e20EDF21461097 88mph yaLINK Pool Bond deployed at 0x140716901E0e17E0EE80daf560A21F85E09A3A16 88mph yaLINK Pool deployed at 0x904F81EFF3c35877865810CCA9a63f2D9cB7D4DD","title":"yEarn aLINK"},{"location":"addresses/#harvest-crvsteth","text":"HarvestMarket deployed at 0xC03e7F63A6Be1198127B7a6eEb5ecD0FBCfF6381 EMAOracle deployed at 0x63667C9390Dcb2D9b3f9b8Ac3321d916B4710532 88mph Harvest CRV:STETH Pool Deposit deployed at 0x6a76f1c362f2C871BEB9d930c9eFd02B07841A28 88mph Harvest CRV:STETH Pool Bond deployed at 0x485Efaa71A64C9283f7cf7Ef444751eB31281795 88mph Harvest CRV:STETH Pool deployed at 0x303CB7Ede0c3AD99CE017CDC3aBAcD65164Ff486","title":"Harvest CRV:STETH"},{"location":"addresses/#harvest-crvrenwbtc","text":"HarvestMarket deployed at 0xD614307FbE4ecE3960f2BB6Ec7863905515AF037 EMAOracle deployed at 0x0AA404FdDFf7943d8b87089F009a7b98EAFC8f8B 88mph Harvest CRV:RENWBTC Pool Deposit deployed at 0xa08b1215ff7Ad33fa431E35569F95F684Cd9Bf9c 88mph Harvest CRV:RENWBTC Pool Bond deployed at 0x3c835F69208884A553025a3B3d2AE46D3b059852 88mph Harvest CRV:RENWBTC Pool deployed at 0x22E6b9A65163CE1225D1F65EF7942a979d093039","title":"Harvest CRV:RENWBTC"},{"location":"faq/","text":"Frequently Asked Questions # Coming soon...","title":"Frequently Asked Questions"},{"location":"faq/#frequently-asked-questions","text":"Coming soon...","title":"Frequently Asked Questions"},{"location":"howitworks/","text":"How 88mph works # Overview # What exactly happens when you, say, deposit 100 tokens into 88mph for 1 year at 10% fixed-rate APY? Your 100 tokens is transferred to 88mph. 88mph deposits the 100 tokens into a yield-generating protocol (Compound, Aave, etc.) with variable rate APY, which will generate yield for the 1 year deposit period. Once the 1 year is over, you withdraw 110 tokens from 88mph. At first glance, this may seem extremely problematic. To begin with, how is this different from simply juggling your own money around? Secondly, if the yield-generating protocol failed to generate 10 tokens of yield from the 100 tokens given to it in 1 year, you can't guarantee that you can withdraw 110 tokens from 88mph. These objections are resolved by 88mph via 2 main derisking mechanisms described below. Pooling the deposits together. Funding the system's debt via the floating-rate bonds. 1. How would pooling help? # Pooling deposits means putting the deposited tokens into a single pool, from which users can withdraw a deposit once its deposit period is over. Risk balancing : If the floating rate APY rose after a deposit, the yield generated by the deposited funds could be more than the interest promised to the user. This surplus would be able to balance out the debt caused by deposits where the floating rate has dropped since the time of deposit. This way, risk of insolvency is reduced for the users, and the stability of 88mph's interest rate is supported. 2. How would floating-rate bonds help? # Simply doing the above, though, wouldn't help if the floating rate APY drops to a very low value and stays there for a long time, deposits made when the floating rate was still high would not by themselves generate enough interest to cover the original interest payouts, and neither would the deposits made after the rates dropped help with this situation. This would cause a pool-wide insolvency event. This is why 88mph also offers another mechanism called floating-rate bonds . The Floating-Rate Bond (FRB) allows users to fund the debt created by the users' deposits, referred as Fixed-Interest Rate Bonds (FIRB). The debt is the fixed-interest rate promised to FIRB holders. You will earn the variable rate offered by the underlying protocol (Compound, Aave, etc.) on the debt funded + the FIRB initial deposit. As the FIRB takes 50% of the floating-rate\u2019s 30-day exponential moving average from the underlying money market protocol like Compound, Aave, if this protocol\u2019s floating-interest rate doesn't drop by more than 50%, as a floating-rate bond holder, you will be in profit. This profit can increase if the underlying variable-rate interest increases. To sum it up, funding floating-rate bonds allows someone to immediately fill up the debt of one or more FIRB, and in exchange they would receive the yield generated by those FIRB. Notes : a 3rd derisking mechanism is currently explored in collaboration with insurance protocol partners, via the creation of products similar in their essence with the traditional Credit Default Swaps. We'll communicate more on this after our v3 release. Interest rate model # At the moment, 88mph uses a linear model for determining the fixed interest rate offered to depositors. 88mph keeps track of the Exponential Moving Average (EMA) of the underlying yield protocol's APY over roughly a monthly window, and offers 50% of the EMA as the fixed rate. We have plans to implement more sophisticated interest rate models in the future that take into account parameters such as the pool surplus/debt, floating-rate volatility, pool total deposit, and so on. Towards structured products # The first line of products offered by 88mph could allow us or another protocol to build structured products on top of our first layer, guaranteeing the capital or a significant portion of such to maturity. We could imagine a mechanism that gives rise to this structure by the combination of a fixed income instrument and the use of derivatives, in this case in particular, an option (eg hegic.co ). As far as we know, there is nothing like that in DeFi, so it could be a new market segment to explore after stabilizing our first layer of products. Interoperability through Non-fungible tokens (NFTs) # 88mph represents deposits and bonds using ERC-721 standard non-fungible tokens. This means that users can transfer them between accounts, buy or sell them on exchanges, put wrappers around them to add more features, and more! The limit is your imagination. Some possible use cases: Deposited a lot of money into 88mph, but suddenly need cash? And you still want your deposit to generate profit? Well, you can take out a loan on lending platforms like RocketNFT using your deposit NFT as collateral, and pay it back once you withdraw your deposit. Magic! You can wrap your bond NFT with an ERC20 token to sell it out fractionally. Or simply attach a creation of your favorite NFT-artist.","title":"How 88mph works"},{"location":"howitworks/#how-88mph-works","text":"","title":"How 88mph works"},{"location":"howitworks/#overview","text":"What exactly happens when you, say, deposit 100 tokens into 88mph for 1 year at 10% fixed-rate APY? Your 100 tokens is transferred to 88mph. 88mph deposits the 100 tokens into a yield-generating protocol (Compound, Aave, etc.) with variable rate APY, which will generate yield for the 1 year deposit period. Once the 1 year is over, you withdraw 110 tokens from 88mph. At first glance, this may seem extremely problematic. To begin with, how is this different from simply juggling your own money around? Secondly, if the yield-generating protocol failed to generate 10 tokens of yield from the 100 tokens given to it in 1 year, you can't guarantee that you can withdraw 110 tokens from 88mph. These objections are resolved by 88mph via 2 main derisking mechanisms described below. Pooling the deposits together. Funding the system's debt via the floating-rate bonds.","title":"Overview"},{"location":"howitworks/#1-how-would-pooling-help","text":"Pooling deposits means putting the deposited tokens into a single pool, from which users can withdraw a deposit once its deposit period is over. Risk balancing : If the floating rate APY rose after a deposit, the yield generated by the deposited funds could be more than the interest promised to the user. This surplus would be able to balance out the debt caused by deposits where the floating rate has dropped since the time of deposit. This way, risk of insolvency is reduced for the users, and the stability of 88mph's interest rate is supported.","title":"1. How would pooling help?"},{"location":"howitworks/#2-how-would-floating-rate-bonds-help","text":"Simply doing the above, though, wouldn't help if the floating rate APY drops to a very low value and stays there for a long time, deposits made when the floating rate was still high would not by themselves generate enough interest to cover the original interest payouts, and neither would the deposits made after the rates dropped help with this situation. This would cause a pool-wide insolvency event. This is why 88mph also offers another mechanism called floating-rate bonds . The Floating-Rate Bond (FRB) allows users to fund the debt created by the users' deposits, referred as Fixed-Interest Rate Bonds (FIRB). The debt is the fixed-interest rate promised to FIRB holders. You will earn the variable rate offered by the underlying protocol (Compound, Aave, etc.) on the debt funded + the FIRB initial deposit. As the FIRB takes 50% of the floating-rate\u2019s 30-day exponential moving average from the underlying money market protocol like Compound, Aave, if this protocol\u2019s floating-interest rate doesn't drop by more than 50%, as a floating-rate bond holder, you will be in profit. This profit can increase if the underlying variable-rate interest increases. To sum it up, funding floating-rate bonds allows someone to immediately fill up the debt of one or more FIRB, and in exchange they would receive the yield generated by those FIRB. Notes : a 3rd derisking mechanism is currently explored in collaboration with insurance protocol partners, via the creation of products similar in their essence with the traditional Credit Default Swaps. We'll communicate more on this after our v3 release.","title":"2. How would floating-rate bonds help?"},{"location":"howitworks/#interest-rate-model","text":"At the moment, 88mph uses a linear model for determining the fixed interest rate offered to depositors. 88mph keeps track of the Exponential Moving Average (EMA) of the underlying yield protocol's APY over roughly a monthly window, and offers 50% of the EMA as the fixed rate. We have plans to implement more sophisticated interest rate models in the future that take into account parameters such as the pool surplus/debt, floating-rate volatility, pool total deposit, and so on.","title":"Interest rate model"},{"location":"howitworks/#towards-structured-products","text":"The first line of products offered by 88mph could allow us or another protocol to build structured products on top of our first layer, guaranteeing the capital or a significant portion of such to maturity. We could imagine a mechanism that gives rise to this structure by the combination of a fixed income instrument and the use of derivatives, in this case in particular, an option (eg hegic.co ). As far as we know, there is nothing like that in DeFi, so it could be a new market segment to explore after stabilizing our first layer of products.","title":"Towards structured products"},{"location":"howitworks/#interoperability-through-non-fungible-tokens-nfts","text":"88mph represents deposits and bonds using ERC-721 standard non-fungible tokens. This means that users can transfer them between accounts, buy or sell them on exchanges, put wrappers around them to add more features, and more! The limit is your imagination. Some possible use cases: Deposited a lot of money into 88mph, but suddenly need cash? And you still want your deposit to generate profit? Well, you can take out a loan on lending platforms like RocketNFT using your deposit NFT as collateral, and pay it back once you withdraw your deposit. Magic! You can wrap your bond NFT with an ERC20 token to sell it out fractionally. Or simply attach a creation of your favorite NFT-artist.","title":"Interoperability through Non-fungible tokens (NFTs)"},{"location":"integration-guide/","text":"Integration guide # Smart contract # To interact with an 88mph pool, you will mostly call the pool's DInterest contract. You can find the source code on our GitHub , and the reference is available here . Creating a deposit # Creating a deposit has two steps: Give ERC-20 approval to the DInterest contract, the amount of which is at least the deposit amount. Call DInterest::deposit() or DInterest::multiDeposit() . Once an account makes a deposit, the account will also receive vested MPH rewards. Check Withdrawing vested MPH rewards to learn more. Example # DInterest pool = DInterest(0x35966201A7724b952455B73A36C8846D8745218e); // Compound DAI pool ERC20 token = ERC20(0x6b175474e89094c44da98b954eedeac495271d0f); // DAI uint256 depositAmount = 3 * 10 ** 18; // 3 DAI uint256 maturationTimestamp = now + 365 days; require(token.approve(address(pool), depositAmount)); pool.deposit(depositAmount, maturationTimestamp); uint256 depositID = pool.depositsLength(); // the ID of the deposit Withdrawing a deposit # Withdrawing a deposit has the following steps: Approve the MPH payback amount to the MPHMinter contract. Call DInterest::withdraw() or DInterest::multiWithdraw() . If you're withdrawing a deposit before its maturation date, call DInterest::earlyWithdraw() or DInterest::multiEarlyWithdraw() . To withdraw a deposit whose debt was funded by a floating-rate bond, you need to input the ID of the floating-rate bond as an argument (fundingID). To obtain this value, you can use our GraphQL API . Example # Let's say we want to withdraw a deposit from the Compound DAI pool with ID 10. First, we make a GraphQL query to obtain the fundingID. { deposits(where: {pool: \"0x35966201a7724b952455b73a36c8846d8745218e\", nftID: 10}) { fundingID } } The response would be { \"data\": { \"deposits\": [ { \"fundingID\": \"4\" } ] } } Now we know the fundingID is 4. Next, we make the smart contract call. MPHToken mph = MPHToken(0x8888801af4d980682e47f1a9036e589479e835c5); DInterest pool = DInterest(0x35966201A7724b952455B73A36C8846D8745218e); // Compound DAI pool MPHMinter mphMinter = pool.mphMinter(); uint256 depositID = 10; uint256 fundingID = 4; mph.approve(address(mphMinter), uint256(-1)); // Infinite approval pool.withdraw(depositID, fundingID); Withdrawing vested MPH rewards # Each deposit (and in the future, floating-rate bond) yields vested MPH rewards to the user. This is handled by the Vesting contract . The vesting is linear and continuous, and is done over 7 days (though this value may change). In order to withdraw vested MPH, you need to call Vesting::withdrawVested(address account, uint256 vestIdx) . You need the index of a vesting object, vestIdx , in order to withdraw the MPH. There are several important things to note: A vesting object's index is not tied to the ID of a deposit or a floating-rate bond. Vesting MPH to another account is something that anyone can do by calling Vesting::vest() , which would increment the highest vest index. Even though it is likely the case that vestIdx = depositID - 1 ( vestIdx is 0-indexed while depositID is 1-indexed), there should be contingencies for handling cases where this is not true. For instance, you can have a function that allows you to call withdrawVested() with an arbitrary vestIdx and update whatever state you need updated. withdrawVested() can be used to withdraw vested MPH to any account by any account, so it is possible (but not likely) that someone would call it for your contract and vest MPH to it. You would want a function that can deal with this situation, which should have the same logic as a function that handles MPH that's mistakenly sent to your contract. Example # Vesting vesting = Vesting(0x8943eb8F104bCf826910e7d2f4D59edfe018e0e7); address account = ...; uint256 vestIdx = ...; vesting.withdrawVested(account, vestIdx); Buying a floating-rate bond # Buying a floating-rate bond takes two steps: Approve deposit tokens to the DInterest contract, the amount of which should be at least the cost of the bond. Call DInterest::fundAll() or DInterest::fundMultiple() to either fund all deposits with outstanding debt or a subset of them. Computing the exact cost of the bond is slightly complicated if you call fundMultiple() , if you're interested you can checkout the source code here . If you call fundAll() then the cost is just DInterest::surplus() . It is usually okay to just give infinite approval to save gas and simplify the code. Example # DInterest pool = DInterest(0x35966201A7724b952455B73A36C8846D8745218e); // Compound DAI pool ERC20 token = ERC20(0x6b175474e89094c44da98b954eedeac495271d0f); // DAI require(token.approve(address(pool), uint256(-1))); // Infinite approval pool.fundAll(); uint256 fundingID = pool.fundingListLength(); // The ID of the floating-rate bond object Zero coupon bonds # Minting a zero coupon bond # ZeroCouponBond bond = ZeroCouponBond(0x6d6d543fe4e2f62dd0c9d4a79e18f0b43ddd12ea); DInterest pool = bond.pool(); NFT depositNFT = pool.depositNFT(); MPHToken mph = MPHToken(0x8888801aF4d980682e47f1A9036e589479e835C5); DInterest.Deposit memory depositStruct = pool.getDeposit(nftID); uint256 nftID = 3; string memory fractionalDepositName = \"Fractional deposit\"; string memory fractionalDepositSymbol = \"FRD\"; mph.increaseAllowance(address(bond), depositStruct.mintMPHAmount); depositNFT.setApprovalForAll(address(bond), true); (uint256 zeroCouponBondsAmount, FractionalDeposit fractionalDeposit) = bond.mintWithDepositNFT(nftID, fractionalDepositName, fractionalDepositSymbol); Redeeming zero coupon bonds for their face value # ZeroCouponBond bond = ZeroCouponBond(0x6d6d543fe4e2f62dd0c9d4a79e18f0b43ddd12ea); uint256 redeemAmount = 30 * (10 ** 18); uint256 actualRedeemedAmount = bond.redeemStablecoin(redeemAmount); Withdrawing an underlying deposit # ZeroCouponBond bond = ZeroCouponBond(0x6d6d543fe4e2f62dd0c9d4a79e18f0b43ddd12ea); address fractionalDepositAddress = 0x1234...; uint256 fundingID = 3; // the ID of the floating-rate bond that funded the deposit's fixed-rate interest bond.redeemFractionalDepositShares(fractionalDepositAddress, fundingID); REST API # We offer a REST API for fetching basic info of 88mph pools. The endpoint is at https://api.88mph.app/pools . The only supported method is GET. Example response # [ { \"address\": \"0xb1abaac351e06d40441cf2cd97f6f0098e6473f2\", // the pool's DInterest contract \"token\": \"0x5b5cfe992adac0c9d48e05854b2d91c73a003858\", // the deposit token address \"tokenSymbol\": \"CRV:HUSD\", // the deposit token symbol \"protocol\": \"Harvest\", // the pool's underlying lending protocol (e.g. Compound, Aave, Harvest) \"oneYearInterestRate\": \"3.6621277863445296\", // the fixed interest rate, in percent (e.g. 3.6 means 3.6%) \"mphAPY\": \"60.8988450243270707253\", // the MPH APY after deducting the payback amount, in percent \"totalValueLockedInToken\": \"1548211.678555032702255836\", // the TVL denominated in the deposit token \"totalValueLockedInUSD\": \"1548211.678555032702255836\" // the TVL denominated in USD }, ... ]","title":"Integration guide"},{"location":"integration-guide/#integration-guide","text":"","title":"Integration guide"},{"location":"integration-guide/#smart-contract","text":"To interact with an 88mph pool, you will mostly call the pool's DInterest contract. You can find the source code on our GitHub , and the reference is available here .","title":"Smart contract"},{"location":"integration-guide/#creating-a-deposit","text":"Creating a deposit has two steps: Give ERC-20 approval to the DInterest contract, the amount of which is at least the deposit amount. Call DInterest::deposit() or DInterest::multiDeposit() . Once an account makes a deposit, the account will also receive vested MPH rewards. Check Withdrawing vested MPH rewards to learn more.","title":"Creating a deposit"},{"location":"integration-guide/#example","text":"DInterest pool = DInterest(0x35966201A7724b952455B73A36C8846D8745218e); // Compound DAI pool ERC20 token = ERC20(0x6b175474e89094c44da98b954eedeac495271d0f); // DAI uint256 depositAmount = 3 * 10 ** 18; // 3 DAI uint256 maturationTimestamp = now + 365 days; require(token.approve(address(pool), depositAmount)); pool.deposit(depositAmount, maturationTimestamp); uint256 depositID = pool.depositsLength(); // the ID of the deposit","title":"Example"},{"location":"integration-guide/#withdrawing-a-deposit","text":"Withdrawing a deposit has the following steps: Approve the MPH payback amount to the MPHMinter contract. Call DInterest::withdraw() or DInterest::multiWithdraw() . If you're withdrawing a deposit before its maturation date, call DInterest::earlyWithdraw() or DInterest::multiEarlyWithdraw() . To withdraw a deposit whose debt was funded by a floating-rate bond, you need to input the ID of the floating-rate bond as an argument (fundingID). To obtain this value, you can use our GraphQL API .","title":"Withdrawing a deposit"},{"location":"integration-guide/#example_1","text":"Let's say we want to withdraw a deposit from the Compound DAI pool with ID 10. First, we make a GraphQL query to obtain the fundingID. { deposits(where: {pool: \"0x35966201a7724b952455b73a36c8846d8745218e\", nftID: 10}) { fundingID } } The response would be { \"data\": { \"deposits\": [ { \"fundingID\": \"4\" } ] } } Now we know the fundingID is 4. Next, we make the smart contract call. MPHToken mph = MPHToken(0x8888801af4d980682e47f1a9036e589479e835c5); DInterest pool = DInterest(0x35966201A7724b952455B73A36C8846D8745218e); // Compound DAI pool MPHMinter mphMinter = pool.mphMinter(); uint256 depositID = 10; uint256 fundingID = 4; mph.approve(address(mphMinter), uint256(-1)); // Infinite approval pool.withdraw(depositID, fundingID);","title":"Example"},{"location":"integration-guide/#withdrawing-vested-mph-rewards","text":"Each deposit (and in the future, floating-rate bond) yields vested MPH rewards to the user. This is handled by the Vesting contract . The vesting is linear and continuous, and is done over 7 days (though this value may change). In order to withdraw vested MPH, you need to call Vesting::withdrawVested(address account, uint256 vestIdx) . You need the index of a vesting object, vestIdx , in order to withdraw the MPH. There are several important things to note: A vesting object's index is not tied to the ID of a deposit or a floating-rate bond. Vesting MPH to another account is something that anyone can do by calling Vesting::vest() , which would increment the highest vest index. Even though it is likely the case that vestIdx = depositID - 1 ( vestIdx is 0-indexed while depositID is 1-indexed), there should be contingencies for handling cases where this is not true. For instance, you can have a function that allows you to call withdrawVested() with an arbitrary vestIdx and update whatever state you need updated. withdrawVested() can be used to withdraw vested MPH to any account by any account, so it is possible (but not likely) that someone would call it for your contract and vest MPH to it. You would want a function that can deal with this situation, which should have the same logic as a function that handles MPH that's mistakenly sent to your contract.","title":"Withdrawing vested MPH rewards"},{"location":"integration-guide/#example_2","text":"Vesting vesting = Vesting(0x8943eb8F104bCf826910e7d2f4D59edfe018e0e7); address account = ...; uint256 vestIdx = ...; vesting.withdrawVested(account, vestIdx);","title":"Example"},{"location":"integration-guide/#buying-a-floating-rate-bond","text":"Buying a floating-rate bond takes two steps: Approve deposit tokens to the DInterest contract, the amount of which should be at least the cost of the bond. Call DInterest::fundAll() or DInterest::fundMultiple() to either fund all deposits with outstanding debt or a subset of them. Computing the exact cost of the bond is slightly complicated if you call fundMultiple() , if you're interested you can checkout the source code here . If you call fundAll() then the cost is just DInterest::surplus() . It is usually okay to just give infinite approval to save gas and simplify the code.","title":"Buying a floating-rate bond"},{"location":"integration-guide/#example_3","text":"DInterest pool = DInterest(0x35966201A7724b952455B73A36C8846D8745218e); // Compound DAI pool ERC20 token = ERC20(0x6b175474e89094c44da98b954eedeac495271d0f); // DAI require(token.approve(address(pool), uint256(-1))); // Infinite approval pool.fundAll(); uint256 fundingID = pool.fundingListLength(); // The ID of the floating-rate bond object","title":"Example"},{"location":"integration-guide/#zero-coupon-bonds","text":"","title":"Zero coupon bonds"},{"location":"integration-guide/#minting-a-zero-coupon-bond","text":"ZeroCouponBond bond = ZeroCouponBond(0x6d6d543fe4e2f62dd0c9d4a79e18f0b43ddd12ea); DInterest pool = bond.pool(); NFT depositNFT = pool.depositNFT(); MPHToken mph = MPHToken(0x8888801aF4d980682e47f1A9036e589479e835C5); DInterest.Deposit memory depositStruct = pool.getDeposit(nftID); uint256 nftID = 3; string memory fractionalDepositName = \"Fractional deposit\"; string memory fractionalDepositSymbol = \"FRD\"; mph.increaseAllowance(address(bond), depositStruct.mintMPHAmount); depositNFT.setApprovalForAll(address(bond), true); (uint256 zeroCouponBondsAmount, FractionalDeposit fractionalDeposit) = bond.mintWithDepositNFT(nftID, fractionalDepositName, fractionalDepositSymbol);","title":"Minting a zero coupon bond"},{"location":"integration-guide/#redeeming-zero-coupon-bonds-for-their-face-value","text":"ZeroCouponBond bond = ZeroCouponBond(0x6d6d543fe4e2f62dd0c9d4a79e18f0b43ddd12ea); uint256 redeemAmount = 30 * (10 ** 18); uint256 actualRedeemedAmount = bond.redeemStablecoin(redeemAmount);","title":"Redeeming zero coupon bonds for their face value"},{"location":"integration-guide/#withdrawing-an-underlying-deposit","text":"ZeroCouponBond bond = ZeroCouponBond(0x6d6d543fe4e2f62dd0c9d4a79e18f0b43ddd12ea); address fractionalDepositAddress = 0x1234...; uint256 fundingID = 3; // the ID of the floating-rate bond that funded the deposit's fixed-rate interest bond.redeemFractionalDepositShares(fractionalDepositAddress, fundingID);","title":"Withdrawing an underlying deposit"},{"location":"integration-guide/#rest-api","text":"We offer a REST API for fetching basic info of 88mph pools. The endpoint is at https://api.88mph.app/pools . The only supported method is GET.","title":"REST API"},{"location":"integration-guide/#example-response","text":"[ { \"address\": \"0xb1abaac351e06d40441cf2cd97f6f0098e6473f2\", // the pool's DInterest contract \"token\": \"0x5b5cfe992adac0c9d48e05854b2d91c73a003858\", // the deposit token address \"tokenSymbol\": \"CRV:HUSD\", // the deposit token symbol \"protocol\": \"Harvest\", // the pool's underlying lending protocol (e.g. Compound, Aave, Harvest) \"oneYearInterestRate\": \"3.6621277863445296\", // the fixed interest rate, in percent (e.g. 3.6 means 3.6%) \"mphAPY\": \"60.8988450243270707253\", // the MPH APY after deducting the payback amount, in percent \"totalValueLockedInToken\": \"1548211.678555032702255836\", // the TVL denominated in the deposit token \"totalValueLockedInUSD\": \"1548211.678555032702255836\" // the TVL denominated in USD }, ... ]","title":"Example response"},{"location":"mph/","text":"MPH tokenomics # Initial issuance # An initial supply of 88,000 MPH was minted and will be distributed via liquidity mining. It begins at 12:00 pm PT 11/20/2020 and lasts 14 days. To participate, follow these steps: Deposit into an 88mph fixed-rate APY pool. This will give you some upfront MPH. Provide liquidity to the MPH-ETH Uniswap pair Stake the Uniswap LP token here Unstake when you want without penalty. MPH token address: 0x8888801af4d980682e47f1a9036e589479e835c5 Total supply # The MPH total supply depends on TVL's growth. Currently, 88mph incentivizes the lenders to deposit their funds in the fixed-rate APY pools by rewarding them with new MPH distributed according to an issuance rate . The upcoming governance will be in charge to monitor the protocol's parameters and decide from where the MPH rewards come from (new issuance and/or governance treasury ). So it's up to the MPH holders to decide how to stimulate TVL growth, and by doing so, generate more revenues for MPH stakers , without diluting too much early adopters. Therefore, you can conclude that there isn't a maximum supply but the total supply is in the hand of the MPH holders. You should also note that the MPH circulating supply is a more accurate metric to access the current value of the protocol. The reason behind this statement is that the majority of the MPH distributed to lenders must be paid back when the lenders withdraw their principal. They are then sent to the governance treasury . In other words, a big percentage of the MPH supply will end up in the governance treasury at any point in the future, excluding this supply from the open market and the MPH staking system. More about the benefits of such design could be found on Placeholder.vc . Depositor rewards # When a user makes a deposit in an 88mph pool, they will receive newly-minted MPH tokens proportional to depositAmount \\times depositPeriod , which will be continuously vested over 270 days (the next release will make it equal to the deposit maturation). They can then stake this MPH in the MPH rewards pool to earn their share of protocol fees and yield-farming rewards. When the deposit is mature and the user wants to withdraw it, they will have to pay back a proportion of the MPH reward (currently between 30% and 90%). These MPH tokens will be sent to the 88mph governance treasury, where MPH holders can vote on how to spend them. This distribution model ensures that existing users will have an amplified influence in the governance process and income sharing, which aligns the interest of the protocol with the interest of the users, rather than the interest of speculators. Bond buyer rewards # Currently not activated When a user buys a floating-rate bond, they will receive newly-minted MPH tokens when one of the deposits whose debt the bond funded is withdrawn, proportional to depositAmount \\times timeFromBondPurchaseToDepositMaturation . They can then stake this MPH in the MPH rewards pool to earn their share of protocol fees and yield-farming rewards. This reward can also have vesting like depositor rewards, though for now, we don't think it's necessary to enable that. Notes : at the beginning, bonds buyers won't get MPH rewards. Only Fixed-rate deposits users. And we won't allow deposit and bond MPH rewards at the same time. Issuance rate multiplier # The multiplier\u2019s unit is MPH per second per stablecoin (of deposit). So a good way to think about what a smart issuance rate multiplier is: given x stablecoins deposit for 1 year, how much MPH should be rewarded? We preset the issuance rate at relaunch with a lower issuance rate than v1 launch. Temporary MPH reward are distributed to your address over a 270-day vesting period and you keep your permanent MPH reward at maturity. If early withdraw, then 100% of the reward need to be paid back and they are burnt (not adding to the total supply of MPH). We\u2019ll revisit the depositors\u2019 reward shortly after relaunch according to the evolution of the MPH price and the TVL growth in each pool. Note: for issuance rate updates, we use the governance multisig directly as the contract owner. It allows us more flexibility in these early days. We will transition to a timelock after the dust has settled. The protocol's parameters will be ended over to the community token holders when the governance system will be launched. The core team vision is low issuance for the foreseeable future to don\u2019t wreck the liquidity mining program, and don't dilute too much early adopters, while allowing the growth of the deposits TVL to generate sustainable profits for MPH stakers (so we'll probably incentivize more the Compound pools to harvest more COMP). That's the goal and it'll be a test & learn process other the coming days/weeks. MPH Staking rewards (Revenues sharing) # By staking your MPH, you can claim your share of rewards from the 88mph rewards pool where the protocol fee and yield-farming rewards are collected. 88mph distribute 100% of its revenues with the community: 88mph protocol fee: 10% is deducted from the interest when a depositor withdraws. Yield-farming rewards: yield-farmed tokens earned from the protocols 88mph is connected to (COMP, etc.). 88mph's protocol fee and yield-farmed tokens like $COMP need to accumulate in our MPH staking pool before allowing us to swap them for $DAI and distribute the rewards to $MPH stakers. Notes : The MPH staking rewards APY is currently unknown because no fees were generated so far and the COMP harvested require time to accumulate. The 10% fee on the interest earned by lenders is applied only if someone withdraws his principal at maturity. An early withdrawal enquires no fee because the interest generated stays in the pool. It's not distributed to the original lender. It will generate compounded interests for everyone else staying in the fixed-rate APY pool. You can claim and unstake when you want. Developer fund # Whenever MPH is minted by new deposits, an additional 10% of the minted amount is minted and sent to the developer fund. These MPH will be used to pay for future development & maintenance of the protocol. Development funds: 0xfecBad5D60725EB6fd10f8936e02fa203fd27E4b Governance treasury # MPH holders have the power to shape the future of the protocol. A dedicated Snapshot will be live shortly after the protocol launch to enable community control. As previously stated, the governance treasury receives the MPH tokens paid back by depositors when they withdraw their deposits. These MPH will be used by whatever the MPH holders decide on. The governance process works by having users vote with their MPH tokens on various proposals ranging from protocol parameters to smart ways of using the capital assets stored in the treasury for creating new incentives, capitalization, and at the end growth. Governance treasury: 0x56f34826Cc63151f74FA8f701E4f73C5EAae52AD","title":"MPH tokenomics"},{"location":"mph/#mph-tokenomics","text":"","title":"MPH tokenomics"},{"location":"mph/#initial-issuance","text":"An initial supply of 88,000 MPH was minted and will be distributed via liquidity mining. It begins at 12:00 pm PT 11/20/2020 and lasts 14 days. To participate, follow these steps: Deposit into an 88mph fixed-rate APY pool. This will give you some upfront MPH. Provide liquidity to the MPH-ETH Uniswap pair Stake the Uniswap LP token here Unstake when you want without penalty. MPH token address: 0x8888801af4d980682e47f1a9036e589479e835c5","title":"Initial issuance"},{"location":"mph/#total-supply","text":"The MPH total supply depends on TVL's growth. Currently, 88mph incentivizes the lenders to deposit their funds in the fixed-rate APY pools by rewarding them with new MPH distributed according to an issuance rate . The upcoming governance will be in charge to monitor the protocol's parameters and decide from where the MPH rewards come from (new issuance and/or governance treasury ). So it's up to the MPH holders to decide how to stimulate TVL growth, and by doing so, generate more revenues for MPH stakers , without diluting too much early adopters. Therefore, you can conclude that there isn't a maximum supply but the total supply is in the hand of the MPH holders. You should also note that the MPH circulating supply is a more accurate metric to access the current value of the protocol. The reason behind this statement is that the majority of the MPH distributed to lenders must be paid back when the lenders withdraw their principal. They are then sent to the governance treasury . In other words, a big percentage of the MPH supply will end up in the governance treasury at any point in the future, excluding this supply from the open market and the MPH staking system. More about the benefits of such design could be found on Placeholder.vc .","title":"Total supply"},{"location":"mph/#depositor-rewards","text":"When a user makes a deposit in an 88mph pool, they will receive newly-minted MPH tokens proportional to depositAmount \\times depositPeriod , which will be continuously vested over 270 days (the next release will make it equal to the deposit maturation). They can then stake this MPH in the MPH rewards pool to earn their share of protocol fees and yield-farming rewards. When the deposit is mature and the user wants to withdraw it, they will have to pay back a proportion of the MPH reward (currently between 30% and 90%). These MPH tokens will be sent to the 88mph governance treasury, where MPH holders can vote on how to spend them. This distribution model ensures that existing users will have an amplified influence in the governance process and income sharing, which aligns the interest of the protocol with the interest of the users, rather than the interest of speculators.","title":"Depositor rewards"},{"location":"mph/#bond-buyer-rewards","text":"Currently not activated When a user buys a floating-rate bond, they will receive newly-minted MPH tokens when one of the deposits whose debt the bond funded is withdrawn, proportional to depositAmount \\times timeFromBondPurchaseToDepositMaturation . They can then stake this MPH in the MPH rewards pool to earn their share of protocol fees and yield-farming rewards. This reward can also have vesting like depositor rewards, though for now, we don't think it's necessary to enable that. Notes : at the beginning, bonds buyers won't get MPH rewards. Only Fixed-rate deposits users. And we won't allow deposit and bond MPH rewards at the same time.","title":"Bond buyer rewards"},{"location":"mph/#issuance-rate-multiplier","text":"The multiplier\u2019s unit is MPH per second per stablecoin (of deposit). So a good way to think about what a smart issuance rate multiplier is: given x stablecoins deposit for 1 year, how much MPH should be rewarded? We preset the issuance rate at relaunch with a lower issuance rate than v1 launch. Temporary MPH reward are distributed to your address over a 270-day vesting period and you keep your permanent MPH reward at maturity. If early withdraw, then 100% of the reward need to be paid back and they are burnt (not adding to the total supply of MPH). We\u2019ll revisit the depositors\u2019 reward shortly after relaunch according to the evolution of the MPH price and the TVL growth in each pool. Note: for issuance rate updates, we use the governance multisig directly as the contract owner. It allows us more flexibility in these early days. We will transition to a timelock after the dust has settled. The protocol's parameters will be ended over to the community token holders when the governance system will be launched. The core team vision is low issuance for the foreseeable future to don\u2019t wreck the liquidity mining program, and don't dilute too much early adopters, while allowing the growth of the deposits TVL to generate sustainable profits for MPH stakers (so we'll probably incentivize more the Compound pools to harvest more COMP). That's the goal and it'll be a test & learn process other the coming days/weeks.","title":"Issuance rate multiplier"},{"location":"mph/#mph-staking-rewards-revenues-sharing","text":"By staking your MPH, you can claim your share of rewards from the 88mph rewards pool where the protocol fee and yield-farming rewards are collected. 88mph distribute 100% of its revenues with the community: 88mph protocol fee: 10% is deducted from the interest when a depositor withdraws. Yield-farming rewards: yield-farmed tokens earned from the protocols 88mph is connected to (COMP, etc.). 88mph's protocol fee and yield-farmed tokens like $COMP need to accumulate in our MPH staking pool before allowing us to swap them for $DAI and distribute the rewards to $MPH stakers. Notes : The MPH staking rewards APY is currently unknown because no fees were generated so far and the COMP harvested require time to accumulate. The 10% fee on the interest earned by lenders is applied only if someone withdraws his principal at maturity. An early withdrawal enquires no fee because the interest generated stays in the pool. It's not distributed to the original lender. It will generate compounded interests for everyone else staying in the fixed-rate APY pool. You can claim and unstake when you want.","title":"MPH Staking rewards (Revenues sharing)"},{"location":"mph/#developer-fund","text":"Whenever MPH is minted by new deposits, an additional 10% of the minted amount is minted and sent to the developer fund. These MPH will be used to pay for future development & maintenance of the protocol. Development funds: 0xfecBad5D60725EB6fd10f8936e02fa203fd27E4b","title":"Developer fund"},{"location":"mph/#governance-treasury","text":"MPH holders have the power to shape the future of the protocol. A dedicated Snapshot will be live shortly after the protocol launch to enable community control. As previously stated, the governance treasury receives the MPH tokens paid back by depositors when they withdraw their deposits. These MPH will be used by whatever the MPH holders decide on. The governance process works by having users vote with their MPH tokens on various proposals ranging from protocol parameters to smart ways of using the capital assets stored in the treasury for creating new incentives, capitalization, and at the end growth. Governance treasury: 0x56f34826Cc63151f74FA8f701E4f73C5EAae52AD","title":"Governance treasury"},{"location":"smartcontract/","text":"Smart contract reference # The smart contract source code can be found on GitHub . Architecture overview # Each 88mph pool consists of 6 smart contracts: DInterest : The main smart contract that users interact with. Handles depositing, withdrawing, and keeping track of deposits. Emits all of the events used in the subgraph. FeeModel : Determines the fee strategy of 88mph, as well as who receives the fees. MoneyMarket : A wrapper for interacting with yield-generating protocols, and stores all of the user funds. Requires a different one for each protocol. InterestOracle : An oracle for the interest rate of the underlying yield-generating protocol. NFT : Two non-fungible ERC721 tokens, used for representing ownership of deposits and bonds. Globally 88mph has the following contracts for handling things related to the MPH token: MPHToken : The MPH ERC-20 token contract itself. MPHMinter : Responsible for minting & taking back MPH tokens for depositors & bond buyers. Dumper : Responsible for accumulating the protocol fees & yield-farming rewards generated by 88mph pools and exchanging them for DAI. Rewards : The MPH rewards staking contract for distributing the protocol fees & yield-farming rewards. API reference # DInterest # State changing functions # function deposit(uint256 amount, uint256 maturationTimestamp) external # Creates a single deposit for the caller. amount : The amount of stablecoin to deposit. The caller should have already approved the contract to spend this much stablecoin before calling this function. Scaled by 10^{stablecoinDecimals} . maturationTimestamp : The Unix timestamp at and after which the deposit will be able to be withdrawn. In seconds. function withdraw(uint256 depositID, uint256 fundingID) external # Withdraws a single deposit for the caller. The caller must own the deposit NFT with ID depositID . depositID : The index of the deposit to be withdrawn in the deposits array plus 1. fundingID : The index of the funding object that funded the deposit's debt in the fundingList array plus 1. It can be found using our subgraph . Important note # Withdrawing may fail if the 88mph pool has failed to generate enough interest from the underlying money market to cover the promised fixed-rate interest, and no one has funded the difference by buying bonds. This is the main risk of depositing into 88mph. function earlyWithdraw(uint256 depositID, uint256 fundingID) external # Withdraws a single deposit for the caller, before the maturation timestamp. The caller must own the deposit NFT with ID depositID . depositID : The index of the deposit to be withdrawn in the deposits array plus 1. fundingID : The index of the funding object that funded the deposit's debt in the fundingList array plus 1. It can be found using our subgraph . function multiDeposit(uint256[] calldata amountList, uint256[] calldata maturationTimestampList) external # Deposits multiple deposits for the caller. The values at each index in each array will be combined to create a single deposit. amountList : An array of the amounts of stablecoin to deposit. The caller should have already approved the contract to spend this much stablecoin before calling this function. Scaled by 10^{stablecoinDecimals} . maturationTimestampList : An array of the Unix timestamps at and after which the deposits will be able to be withdrawn. In seconds. Input size limit # The maximum recommended number of deposits is 20. function multiWithdraw(uint256[] calldata depositIDList, uint256[] calldata fundingIDList) external # Withdraws multiple deposits for the caller. The caller must own the deposit NFTs with IDs in depositIDList . depositIDList : The indices of the deposits to be withdrawn in the deposits array plus 1. fundingIDList : The indices of the funding objects that funded the deposit's debt in the fundingList array plus 1. It can be found using our subgraph . Input size limit # The maximum recommended number of deposits is 100. Important note # Withdrawing may fail if the 88mph pool has failed to generate enough interest from the underlying money market to cover the promised fixed-rate interest, and no one has funded the difference. This is the main risk of depositing into 88mph. function multiEarlyWithdraw(uint256[] calldata depositIDList, uint256[] calldata fundingIDList) external # Withdraws multiple deposits for the caller, before the maturation timestamp. The caller must own the deposit NFTs with IDs in depositIDList . depositIDList : The indices of the deposits to be withdrawn in the deposits array plus 1. fundingIDList : The indices of the funding objects that funded the deposit's debt in the fundingList array plus 1. It can be found using our subgraph . Input size limit # The maximum recommended number of deposits is 50. function fundAll() external # Allows the caller to fund all of the existing deficit of the 88mph pool. In exchange, the caller receives a funding NFT, and the interest generated by the deposits the caller funded will be sent to the owner of the NFT whenever a deposit they funded is withdrawn. Before calling this function, the caller must approve at least the deficit amount of stablecoin to the DInterest contract. This amount may be obtained using surplus() . To avoid the transaction being reverted, it is recommended to simply set the approval amount to 2^{256}-1 . function fundMultiple(uint256 toDepositID) external # Allows the caller to fund the deficit of multiple deposits. In exchange, the caller receives a funding NFT, and the interest generated by the deposits the caller funded will be sent to the owner of the NFT whenever a deposit they funded is withdrawn. Before calling this function, the caller must approve at least the deficit amount of stablecoin to the DInterest contract. This amount may be obtained using surplusOfDeposit() . To avoid the transaction being reverted, it is recommended to simply set the approval amount to 2^{256}-1 . toDepositID : Deposits with ID from (not including) lastFundedDepositID to (including) toDepositID will be funded. Read only functions # function getDeposit(uint256 depositID) external view returns (uint256 amount, uint256 maturationTimestamp, uint256 initialDeficit, uint256 initialMoneyMarketIncomeIndex, bool active) # Returns info about a user deposit. The owner of the deposit is whichever Ethereum account that owns the ERC721 deposit token with id depositID . Inputs # depositID : The index of the deposit in the deposits array. Returns # uint256 amount : The amount of the deposit, in stablecoins. Scaled by 10^{stablecoinDecimals} . uint256 maturationTimestamp : The Unix timestamp at and after which the deposit will be able to be withdrawn. In seconds. uint256 interestOwed : The initial debt caused by the deposit. uint256 initialMoneyMarketIncomeIndex : The value returned by moneyMarket.incomeIndex() at the time of deposit. bool active : true if the deposit hasn't been withdrawn, false otherwise. bool finalSurplusIsNegative : true if at the time of withdrawal the deposit had a negative surplus, false otherwise. uint256 finalSurplusAmount : The amount of surplus/debt of the deposit at the time of withdrawal. uint256 mintMPHAmount : The amount of MPH tokens minted to the user at the time of deposit. uint256 depositTimestamp : Unix timestamp at time of deposit, in seconds. function getFunding(uint256 fundingID) external view returns (uint256 fromDepositID, uint256 toDepositID, uint256 recordedFundedDepositAmount, uint256 recordedMoneyMarketIncomeIndex) # Returns info about a funding. The owner of the funding (and the account who will receive the interests) is whichever Ethereum account that owns the ERC721 funding token with id fundingID . Inputs # fundingID : The index of the funding in the fundingList array. Returns # fromDepositID : Deposits with ID from (not including) fromDepositID to (including) toDepositID have their deficits funded by this funding instance. toDepositID : Deposits with ID from (not including) fromDepositID to (including) toDepositID have their deficits funded by this funding instance. recordedFundedDepositAmount : The current total deposit amount that is generating interest for the owner of this funding instance, in stablecoins. Scaled by 10^{stablecoinDecimals} . recordedMoneyMarketIncomeIndex : The value returned by moneyMarket.incomeIndex() at the time of the latest withdrawal of a deposit funded by this funding instance. If no funded deposit has been withdrawn yet, this value is equal to the monet market incomeIndex at the time of the funding instance's creation. function MinDepositPeriod() external view returns (uint256) # Returns the minimum deposit period, in seconds. function MaxDepositPeriod() external view returns (uint256) # Returns the maximum deposit period, in seconds. function MinDepositAmount() external view returns (uint256) # Returns the minimum deposit amount for a single deposit in stablecoin . Scaled by 10^{stablecoinDecimals} . function MaxDepositAmount() external view returns (uint256) # Returns the maximum deposit amount for a single deposit in stablecoin . Scaled by 10^{stablecoinDecimals} . function totalDeposit() external view returns (uint256) # Returns the total deposited amount of stablecoin . Scaled by 10^{stablecoinDecimals} . function moneyMarket() external view returns (address) # Returns the address of MoneyMarket . function stablecoin() external view returns (address) # Returns the address of the stablecoin used. function feeModel() external view returns (address) # Returns the address of FeeModel . function interestModel() external view returns (address) # Returns the address of InterestModel . function interestOracle() external view returns (address) # Returns the address of InterestOracle . function depositNFT() external view returns (address) # Returns the address of the ERC721 deposit token. function fundingNFT() external view returns (address) # Returns the address of ERC721 funding token. function calculateInterestAmount(uint256 depositAmount, uint256 depositPeriodInSeconds) external view returns (uint256 interestAmount) # Returns the interest amount given the deposit amount and period. Inputs # depositAmount : The amount of the deposit in stablecoin . Scaled by 10^{stablecoinDecimals} . depositPeriodInSeconds : The length of the deposit's deposit period, in seconds. function surplus() external view returns (bool isNegative, uint256 surplusAmount) # Returns the surplus value of the pool over the owed deposits. Returns # isNegative : Whether the surplus is negative. A negative surplus means there's a deficit. surplusAmount : Amount of the pool's surplus, in stablecoins. Scaled by 10^{stablecoinDecimals} . function surplusOfDeposit(uint256 depositID) external view returns (bool isNegative, uint256 surplusAmount) # Returns the surplus value of a particular deposit. Does not include funding. Inputs # depositID : The index of the deposit to be withdrawn in the deposits array plus 1. Returns # isNegative : Whether the surplus is negative. A negative surplus means there's a deficit. surplusAmount : Amount of the pool's surplus, in stablecoins. Scaled by 10^{stablecoinDecimals} . function depositsLength() external view returns (uint256) # Returns the length of the deposits array. function fundingListLength() external view returns (address) # Returns the length of the fundingList array. function depositIsFunded(uint256 depositID) external view returns (bool) # Inputs # depositID : The index of the deposit to be withdrawn in the deposits array plus 1. Returns # Returns whether or not the deposit's deficit has been funded. function latestFundedDepositID() external view returns (uint256) # Returns the maximum ID among funded deposits. It can be assumed that all deposits with ID less than or equal to this value have been funded. function unfundedUserDepositAmount() external view returns (uint256) # Returns the deposited stablecoin amount whose deficit hasn't been funded. Scaled by 10^{stablecoinDecimals} . FeeModel # Read only functions # function getFee(uint256 _txAmount) external pure returns (uint256 _feeAmount) # Used for determining how much fee to charge from a transaction. Inputs # _txAmount : The amount of the transaction from which a fee will be taken. Returns # _feeAmount : The amount of the fee that will be taken from the transaction. function beneficiary() external view returns (address) # Returns the address who will receive the fees. MoneyMarket # State changing functions # function deposit(uint256 amount) external # Lends amount stablecoins to the underlying money market protocol. Inputs # amount : The amount of stablecoins to be deposited. function withdraw(uint256 amountInUnderlying) external # Withdraws amountInUnderlying stablecoins from the underlying money market protocol. Inputs # amountInUnderlying : The amount of stablecoins to be withdrawn. Read only functions # function totalValue() external returns (uint256) # Returns the total value locked in the money market, in terms of the underlying stablecoin. Scaled by 10^{stablecoinDecimals} . function incomeIndex() external returns (uint256) # Returns an index that can be used to compute the interest generated by the money market over a period of time. Specifically, interestOverPeriod = depositValueAtBeginningOfPeriod \\times \\frac{incomeIndexAtEndOfPeriod}{incomeIndexAtBeginningOfPeriod} . ZeroCouponBond # Read only functions # bool public initialized; DInterest public pool; FractionalDepositFactory public fractionalDepositFactory; ERC20 public stablecoin; uint256 public maturationTimestamp; string public name; string public symbol; uint8 public decimals; State changing functions # function mintWithDepositNFT(uint256 nftID, string calldata fractionalDepositName, string calldata fractionalDepositSymbol) external returns (uint256 zeroCouponBondsAmount, FractionalDeposit fractionalDeposit) # Mints zero coupon bond tokens using a deposit NFT. Inputs # uint256 nftID : the ID of the deposit NFT string calldata fractionalDepositName : the name for the fractionalized deposit token (cosmetic) string calldata fractionalDepositSymbol : the symbol for the fractionalized deposit token (cosmetic) Return values # uint256 zeroCouponBondsAmount : the amount of bonds minted FractionalDeposit fractionalDeposit : the created FractionalDeposit contract for the deposit function redeemStablecoin(uint256 amount) external returns (uint256 actualRedeemedAmount) # Redeems zero coupon bonds for the underlying tokens. If there is not enough tokens to pay out the redemption, the max possible amount is redeemed. Inputs # uint256 amount : the amount of bonds to redeem Return values # uint256 actualRedeemedAmount : the actual redeemed underlying token amount, which may be less than the bonds redeemed function redeemFractionalDepositShares(address fractionalDepositAddress, uint256 fundingID) external # Withdraws the underlying deposit to allow for bond holders to redeem their bonds for the underlying tokens. Inputs # address fractionalDepositAddress : the address of the fractional deposit uint256 fundingID : the ID of the floating-rate bond that funded the deposit's fixed-rate interest","title":"Smart contract reference"},{"location":"smartcontract/#smart-contract-reference","text":"The smart contract source code can be found on GitHub .","title":"Smart contract reference"},{"location":"smartcontract/#architecture-overview","text":"Each 88mph pool consists of 6 smart contracts: DInterest : The main smart contract that users interact with. Handles depositing, withdrawing, and keeping track of deposits. Emits all of the events used in the subgraph. FeeModel : Determines the fee strategy of 88mph, as well as who receives the fees. MoneyMarket : A wrapper for interacting with yield-generating protocols, and stores all of the user funds. Requires a different one for each protocol. InterestOracle : An oracle for the interest rate of the underlying yield-generating protocol. NFT : Two non-fungible ERC721 tokens, used for representing ownership of deposits and bonds. Globally 88mph has the following contracts for handling things related to the MPH token: MPHToken : The MPH ERC-20 token contract itself. MPHMinter : Responsible for minting & taking back MPH tokens for depositors & bond buyers. Dumper : Responsible for accumulating the protocol fees & yield-farming rewards generated by 88mph pools and exchanging them for DAI. Rewards : The MPH rewards staking contract for distributing the protocol fees & yield-farming rewards.","title":"Architecture overview"},{"location":"smartcontract/#api-reference","text":"","title":"API reference"},{"location":"smartcontract/#dinterest","text":"","title":"DInterest"},{"location":"smartcontract/#state-changing-functions","text":"","title":"State changing functions"},{"location":"smartcontract/#function-deposituint256-amount-uint256-maturationtimestamp-external","text":"Creates a single deposit for the caller. amount : The amount of stablecoin to deposit. The caller should have already approved the contract to spend this much stablecoin before calling this function. Scaled by 10^{stablecoinDecimals} . maturationTimestamp : The Unix timestamp at and after which the deposit will be able to be withdrawn. In seconds.","title":"function deposit(uint256 amount, uint256 maturationTimestamp) external"},{"location":"smartcontract/#function-withdrawuint256-depositid-uint256-fundingid-external","text":"Withdraws a single deposit for the caller. The caller must own the deposit NFT with ID depositID . depositID : The index of the deposit to be withdrawn in the deposits array plus 1. fundingID : The index of the funding object that funded the deposit's debt in the fundingList array plus 1. It can be found using our subgraph .","title":"function withdraw(uint256 depositID, uint256 fundingID) external"},{"location":"smartcontract/#important-note","text":"Withdrawing may fail if the 88mph pool has failed to generate enough interest from the underlying money market to cover the promised fixed-rate interest, and no one has funded the difference by buying bonds. This is the main risk of depositing into 88mph.","title":"Important note"},{"location":"smartcontract/#function-earlywithdrawuint256-depositid-uint256-fundingid-external","text":"Withdraws a single deposit for the caller, before the maturation timestamp. The caller must own the deposit NFT with ID depositID . depositID : The index of the deposit to be withdrawn in the deposits array plus 1. fundingID : The index of the funding object that funded the deposit's debt in the fundingList array plus 1. It can be found using our subgraph .","title":"function earlyWithdraw(uint256 depositID, uint256 fundingID) external"},{"location":"smartcontract/#function-multideposituint256-calldata-amountlist-uint256-calldata-maturationtimestamplist-external","text":"Deposits multiple deposits for the caller. The values at each index in each array will be combined to create a single deposit. amountList : An array of the amounts of stablecoin to deposit. The caller should have already approved the contract to spend this much stablecoin before calling this function. Scaled by 10^{stablecoinDecimals} . maturationTimestampList : An array of the Unix timestamps at and after which the deposits will be able to be withdrawn. In seconds.","title":"function multiDeposit(uint256[] calldata amountList, uint256[] calldata maturationTimestampList) external"},{"location":"smartcontract/#input-size-limit","text":"The maximum recommended number of deposits is 20.","title":"Input size limit"},{"location":"smartcontract/#function-multiwithdrawuint256-calldata-depositidlist-uint256-calldata-fundingidlist-external","text":"Withdraws multiple deposits for the caller. The caller must own the deposit NFTs with IDs in depositIDList . depositIDList : The indices of the deposits to be withdrawn in the deposits array plus 1. fundingIDList : The indices of the funding objects that funded the deposit's debt in the fundingList array plus 1. It can be found using our subgraph .","title":"function multiWithdraw(uint256[] calldata depositIDList, uint256[] calldata fundingIDList) external"},{"location":"smartcontract/#input-size-limit_1","text":"The maximum recommended number of deposits is 100.","title":"Input size limit"},{"location":"smartcontract/#important-note_1","text":"Withdrawing may fail if the 88mph pool has failed to generate enough interest from the underlying money market to cover the promised fixed-rate interest, and no one has funded the difference. This is the main risk of depositing into 88mph.","title":"Important note"},{"location":"smartcontract/#function-multiearlywithdrawuint256-calldata-depositidlist-uint256-calldata-fundingidlist-external","text":"Withdraws multiple deposits for the caller, before the maturation timestamp. The caller must own the deposit NFTs with IDs in depositIDList . depositIDList : The indices of the deposits to be withdrawn in the deposits array plus 1. fundingIDList : The indices of the funding objects that funded the deposit's debt in the fundingList array plus 1. It can be found using our subgraph .","title":"function multiEarlyWithdraw(uint256[] calldata depositIDList, uint256[] calldata fundingIDList) external"},{"location":"smartcontract/#input-size-limit_2","text":"The maximum recommended number of deposits is 50.","title":"Input size limit"},{"location":"smartcontract/#function-fundall-external","text":"Allows the caller to fund all of the existing deficit of the 88mph pool. In exchange, the caller receives a funding NFT, and the interest generated by the deposits the caller funded will be sent to the owner of the NFT whenever a deposit they funded is withdrawn. Before calling this function, the caller must approve at least the deficit amount of stablecoin to the DInterest contract. This amount may be obtained using surplus() . To avoid the transaction being reverted, it is recommended to simply set the approval amount to 2^{256}-1 .","title":"function fundAll() external"},{"location":"smartcontract/#function-fundmultipleuint256-todepositid-external","text":"Allows the caller to fund the deficit of multiple deposits. In exchange, the caller receives a funding NFT, and the interest generated by the deposits the caller funded will be sent to the owner of the NFT whenever a deposit they funded is withdrawn. Before calling this function, the caller must approve at least the deficit amount of stablecoin to the DInterest contract. This amount may be obtained using surplusOfDeposit() . To avoid the transaction being reverted, it is recommended to simply set the approval amount to 2^{256}-1 . toDepositID : Deposits with ID from (not including) lastFundedDepositID to (including) toDepositID will be funded.","title":"function fundMultiple(uint256 toDepositID) external"},{"location":"smartcontract/#read-only-functions","text":"","title":"Read only functions"},{"location":"smartcontract/#function-getdeposituint256-depositid-external-view-returns-uint256-amount-uint256-maturationtimestamp-uint256-initialdeficit-uint256-initialmoneymarketincomeindex-bool-active","text":"Returns info about a user deposit. The owner of the deposit is whichever Ethereum account that owns the ERC721 deposit token with id depositID .","title":"function getDeposit(uint256 depositID) external view returns (uint256 amount, uint256 maturationTimestamp, uint256 initialDeficit, uint256 initialMoneyMarketIncomeIndex, bool active)"},{"location":"smartcontract/#inputs","text":"depositID : The index of the deposit in the deposits array.","title":"Inputs"},{"location":"smartcontract/#returns","text":"uint256 amount : The amount of the deposit, in stablecoins. Scaled by 10^{stablecoinDecimals} . uint256 maturationTimestamp : The Unix timestamp at and after which the deposit will be able to be withdrawn. In seconds. uint256 interestOwed : The initial debt caused by the deposit. uint256 initialMoneyMarketIncomeIndex : The value returned by moneyMarket.incomeIndex() at the time of deposit. bool active : true if the deposit hasn't been withdrawn, false otherwise. bool finalSurplusIsNegative : true if at the time of withdrawal the deposit had a negative surplus, false otherwise. uint256 finalSurplusAmount : The amount of surplus/debt of the deposit at the time of withdrawal. uint256 mintMPHAmount : The amount of MPH tokens minted to the user at the time of deposit. uint256 depositTimestamp : Unix timestamp at time of deposit, in seconds.","title":"Returns"},{"location":"smartcontract/#function-getfundinguint256-fundingid-external-view-returns-uint256-fromdepositid-uint256-todepositid-uint256-recordedfundeddepositamount-uint256-recordedmoneymarketincomeindex","text":"Returns info about a funding. The owner of the funding (and the account who will receive the interests) is whichever Ethereum account that owns the ERC721 funding token with id fundingID .","title":"function getFunding(uint256 fundingID) external view returns (uint256 fromDepositID, uint256 toDepositID, uint256 recordedFundedDepositAmount, uint256 recordedMoneyMarketIncomeIndex)"},{"location":"smartcontract/#inputs_1","text":"fundingID : The index of the funding in the fundingList array.","title":"Inputs"},{"location":"smartcontract/#returns_1","text":"fromDepositID : Deposits with ID from (not including) fromDepositID to (including) toDepositID have their deficits funded by this funding instance. toDepositID : Deposits with ID from (not including) fromDepositID to (including) toDepositID have their deficits funded by this funding instance. recordedFundedDepositAmount : The current total deposit amount that is generating interest for the owner of this funding instance, in stablecoins. Scaled by 10^{stablecoinDecimals} . recordedMoneyMarketIncomeIndex : The value returned by moneyMarket.incomeIndex() at the time of the latest withdrawal of a deposit funded by this funding instance. If no funded deposit has been withdrawn yet, this value is equal to the monet market incomeIndex at the time of the funding instance's creation.","title":"Returns"},{"location":"smartcontract/#function-mindepositperiod-external-view-returns-uint256","text":"Returns the minimum deposit period, in seconds.","title":"function MinDepositPeriod() external view returns (uint256)"},{"location":"smartcontract/#function-maxdepositperiod-external-view-returns-uint256","text":"Returns the maximum deposit period, in seconds.","title":"function MaxDepositPeriod() external view returns (uint256)"},{"location":"smartcontract/#function-mindepositamount-external-view-returns-uint256","text":"Returns the minimum deposit amount for a single deposit in stablecoin . Scaled by 10^{stablecoinDecimals} .","title":"function MinDepositAmount() external view returns (uint256)"},{"location":"smartcontract/#function-maxdepositamount-external-view-returns-uint256","text":"Returns the maximum deposit amount for a single deposit in stablecoin . Scaled by 10^{stablecoinDecimals} .","title":"function MaxDepositAmount() external view returns (uint256)"},{"location":"smartcontract/#function-totaldeposit-external-view-returns-uint256","text":"Returns the total deposited amount of stablecoin . Scaled by 10^{stablecoinDecimals} .","title":"function totalDeposit() external view returns (uint256)"},{"location":"smartcontract/#function-moneymarket-external-view-returns-address","text":"Returns the address of MoneyMarket .","title":"function moneyMarket() external view returns (address)"},{"location":"smartcontract/#function-stablecoin-external-view-returns-address","text":"Returns the address of the stablecoin used.","title":"function stablecoin() external view returns (address)"},{"location":"smartcontract/#function-feemodel-external-view-returns-address","text":"Returns the address of FeeModel .","title":"function feeModel() external view returns (address)"},{"location":"smartcontract/#function-interestmodel-external-view-returns-address","text":"Returns the address of InterestModel .","title":"function interestModel() external view returns (address)"},{"location":"smartcontract/#function-interestoracle-external-view-returns-address","text":"Returns the address of InterestOracle .","title":"function interestOracle() external view returns (address)"},{"location":"smartcontract/#function-depositnft-external-view-returns-address","text":"Returns the address of the ERC721 deposit token.","title":"function depositNFT() external view returns (address)"},{"location":"smartcontract/#function-fundingnft-external-view-returns-address","text":"Returns the address of ERC721 funding token.","title":"function fundingNFT() external view returns (address)"},{"location":"smartcontract/#function-calculateinterestamountuint256-depositamount-uint256-depositperiodinseconds-external-view-returns-uint256-interestamount","text":"Returns the interest amount given the deposit amount and period.","title":"function calculateInterestAmount(uint256 depositAmount, uint256 depositPeriodInSeconds) external view returns (uint256 interestAmount)"},{"location":"smartcontract/#inputs_2","text":"depositAmount : The amount of the deposit in stablecoin . Scaled by 10^{stablecoinDecimals} . depositPeriodInSeconds : The length of the deposit's deposit period, in seconds.","title":"Inputs"},{"location":"smartcontract/#function-surplus-external-view-returns-bool-isnegative-uint256-surplusamount","text":"Returns the surplus value of the pool over the owed deposits.","title":"function surplus() external view returns (bool isNegative, uint256 surplusAmount)"},{"location":"smartcontract/#returns_2","text":"isNegative : Whether the surplus is negative. A negative surplus means there's a deficit. surplusAmount : Amount of the pool's surplus, in stablecoins. Scaled by 10^{stablecoinDecimals} .","title":"Returns"},{"location":"smartcontract/#function-surplusofdeposituint256-depositid-external-view-returns-bool-isnegative-uint256-surplusamount","text":"Returns the surplus value of a particular deposit. Does not include funding.","title":"function surplusOfDeposit(uint256 depositID) external view returns (bool isNegative, uint256 surplusAmount)"},{"location":"smartcontract/#inputs_3","text":"depositID : The index of the deposit to be withdrawn in the deposits array plus 1.","title":"Inputs"},{"location":"smartcontract/#returns_3","text":"isNegative : Whether the surplus is negative. A negative surplus means there's a deficit. surplusAmount : Amount of the pool's surplus, in stablecoins. Scaled by 10^{stablecoinDecimals} .","title":"Returns"},{"location":"smartcontract/#function-depositslength-external-view-returns-uint256","text":"Returns the length of the deposits array.","title":"function depositsLength() external view returns (uint256)"},{"location":"smartcontract/#function-fundinglistlength-external-view-returns-address","text":"Returns the length of the fundingList array.","title":"function fundingListLength() external view returns (address)"},{"location":"smartcontract/#function-depositisfundeduint256-depositid-external-view-returns-bool","text":"","title":"function depositIsFunded(uint256 depositID) external view returns (bool)"},{"location":"smartcontract/#inputs_4","text":"depositID : The index of the deposit to be withdrawn in the deposits array plus 1.","title":"Inputs"},{"location":"smartcontract/#returns_4","text":"Returns whether or not the deposit's deficit has been funded.","title":"Returns"},{"location":"smartcontract/#function-latestfundeddepositid-external-view-returns-uint256","text":"Returns the maximum ID among funded deposits. It can be assumed that all deposits with ID less than or equal to this value have been funded.","title":"function latestFundedDepositID() external view returns (uint256)"},{"location":"smartcontract/#function-unfundeduserdepositamount-external-view-returns-uint256","text":"Returns the deposited stablecoin amount whose deficit hasn't been funded. Scaled by 10^{stablecoinDecimals} .","title":"function unfundedUserDepositAmount() external view returns (uint256)"},{"location":"smartcontract/#feemodel","text":"","title":"FeeModel"},{"location":"smartcontract/#read-only-functions_1","text":"","title":"Read only functions"},{"location":"smartcontract/#function-getfeeuint256-_txamount-external-pure-returns-uint256-_feeamount","text":"Used for determining how much fee to charge from a transaction.","title":"function getFee(uint256 _txAmount) external pure returns (uint256 _feeAmount)"},{"location":"smartcontract/#inputs_5","text":"_txAmount : The amount of the transaction from which a fee will be taken.","title":"Inputs"},{"location":"smartcontract/#returns_5","text":"_feeAmount : The amount of the fee that will be taken from the transaction.","title":"Returns"},{"location":"smartcontract/#function-beneficiary-external-view-returns-address","text":"Returns the address who will receive the fees.","title":"function beneficiary() external view returns (address)"},{"location":"smartcontract/#moneymarket","text":"","title":"MoneyMarket"},{"location":"smartcontract/#state-changing-functions_1","text":"","title":"State changing functions"},{"location":"smartcontract/#function-deposituint256-amount-external","text":"Lends amount stablecoins to the underlying money market protocol.","title":"function deposit(uint256 amount) external"},{"location":"smartcontract/#inputs_6","text":"amount : The amount of stablecoins to be deposited.","title":"Inputs"},{"location":"smartcontract/#function-withdrawuint256-amountinunderlying-external","text":"Withdraws amountInUnderlying stablecoins from the underlying money market protocol.","title":"function withdraw(uint256 amountInUnderlying) external"},{"location":"smartcontract/#inputs_7","text":"amountInUnderlying : The amount of stablecoins to be withdrawn.","title":"Inputs"},{"location":"smartcontract/#read-only-functions_2","text":"","title":"Read only functions"},{"location":"smartcontract/#function-totalvalue-external-returns-uint256","text":"Returns the total value locked in the money market, in terms of the underlying stablecoin. Scaled by 10^{stablecoinDecimals} .","title":"function totalValue() external returns (uint256)"},{"location":"smartcontract/#function-incomeindex-external-returns-uint256","text":"Returns an index that can be used to compute the interest generated by the money market over a period of time. Specifically, interestOverPeriod = depositValueAtBeginningOfPeriod \\times \\frac{incomeIndexAtEndOfPeriod}{incomeIndexAtBeginningOfPeriod} .","title":"function incomeIndex() external returns (uint256)"},{"location":"smartcontract/#zerocouponbond","text":"","title":"ZeroCouponBond"},{"location":"smartcontract/#read-only-functions_3","text":"bool public initialized; DInterest public pool; FractionalDepositFactory public fractionalDepositFactory; ERC20 public stablecoin; uint256 public maturationTimestamp; string public name; string public symbol; uint8 public decimals;","title":"Read only functions"},{"location":"smartcontract/#state-changing-functions_2","text":"","title":"State changing functions"},{"location":"smartcontract/#function-mintwithdepositnftuint256-nftid-string-calldata-fractionaldepositname-string-calldata-fractionaldepositsymbol-external-returns-uint256-zerocouponbondsamount-fractionaldeposit-fractionaldeposit","text":"Mints zero coupon bond tokens using a deposit NFT.","title":"function mintWithDepositNFT(uint256 nftID, string calldata fractionalDepositName, string calldata fractionalDepositSymbol) external returns (uint256 zeroCouponBondsAmount, FractionalDeposit fractionalDeposit)"},{"location":"smartcontract/#inputs_8","text":"uint256 nftID : the ID of the deposit NFT string calldata fractionalDepositName : the name for the fractionalized deposit token (cosmetic) string calldata fractionalDepositSymbol : the symbol for the fractionalized deposit token (cosmetic)","title":"Inputs"},{"location":"smartcontract/#return-values","text":"uint256 zeroCouponBondsAmount : the amount of bonds minted FractionalDeposit fractionalDeposit : the created FractionalDeposit contract for the deposit","title":"Return values"},{"location":"smartcontract/#function-redeemstablecoinuint256-amount-external-returns-uint256-actualredeemedamount","text":"Redeems zero coupon bonds for the underlying tokens. If there is not enough tokens to pay out the redemption, the max possible amount is redeemed.","title":"function redeemStablecoin(uint256 amount) external returns (uint256 actualRedeemedAmount)"},{"location":"smartcontract/#inputs_9","text":"uint256 amount : the amount of bonds to redeem","title":"Inputs"},{"location":"smartcontract/#return-values_1","text":"uint256 actualRedeemedAmount : the actual redeemed underlying token amount, which may be less than the bonds redeemed","title":"Return values"},{"location":"smartcontract/#function-redeemfractionaldepositsharesaddress-fractionaldepositaddress-uint256-fundingid-external","text":"Withdraws the underlying deposit to allow for bond holders to redeem their bonds for the underlying tokens.","title":"function redeemFractionalDepositShares(address fractionalDepositAddress, uint256 fundingID) external"},{"location":"smartcontract/#inputs_10","text":"address fractionalDepositAddress : the address of the fractional deposit uint256 fundingID : the ID of the floating-rate bond that funded the deposit's fixed-rate interest","title":"Inputs"}]}